<h1>Симметрическая разность произвольного количества исходных множеств</h1>
<h2>Алгоритм:</h2>
<p>Создаем класс Arr, в котором наше множество будет представлено вектором элементов типа string. Методы, которые реализованы классе:</p>
<p>void Add(string e)- добавление элемента в массив</p>
<p>void Print()- вывод множества в консоль</p>
<p>void SummetricDifference(Arr set)- симметрическая разность для двух множеств</p>
<p>void SummetricDifferences(vector)- симметрическая разность для более двух множеств</p>
<p>int contains(string e)- подсчет, сколько элементов е содержится в множестве</p>
<p>void Del(string e, int i, int&size)- удаления элементов как е в множестве, начиная с i+1 элемента</p>
<p>bool check(vector<Arr>set, string e)- проверка на наличие элемента</p>
<p>Arr Union(vector<Arr>set)- объединение н-ого кол-ва множеств</p>
<p>Arr Cross(vector<Arr>set)- пересечение н-ного кол-ва множеств</p>
<h3>Симметричкая разность двух множеств:</h3>
<p>Заходим в первое множество, берем оттуда первый элемент. Сразу же подсчитываем с помощью int contains(string e), сколько таких элементов в множестве, а так же последующие такие элементы в множестве функцией Del. После этого ищем такой элемент во втором множестве. Если находим, точно так же считаем сколько таких элементов во втором множестве и удаляем повторяющиеся. Далее отнимаем кол-во данного элемента первого множества от кол-во данного элемента из второго множества. Полученное кол-во, по модулю, добавляем элемент в множество-результат. Берем следующий элемент из первого множества, повторяем действия, пока не дойдем до конца первого множества. То же самое повторяем сначала заходя во второе множество, а потом в первое, чтобы не потерять элементы.</p>
<h3>Симметрическая разность для двух и более множеств:</h3>
<p>Находить симметрическую разность некоторого кол-ва множеств будет через разность объединения и пересечения двух множеств. Для объединение множеств мы проходимся по всем множествам и подсчитываем кол-ва попадания определенного элемента в каждом множестве. В результат закидываем наибольшее кол-во данного элемента в одном из множеств, т.е. если в одном множестве элемент встречается 2 раза, а в другом 3, то в результате будет тоже 3. Для пересечения же наоборот добавляем наименьшее число данного элемента. По итогу у нас два множества, а для двух множеств функция была описана выше.</p>
